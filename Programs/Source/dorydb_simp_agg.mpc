# sint: secret integers

# you can assign public numbers to sint

# no of conditions
c = 5
# no of records in DB
R = (1 << 16)
# no of features in DB
# assuming = c now
ftrs = c + 1

db = Matrix(R, ftrs, sint)
intervals = Matrix(c, 2, sint)

# use @for_range_opt for balanced optimization 
# but use Python loops if compile-time numbers are need (e.g., for players)

@for_range_opt_multithread(8, R)
def _(i):
    # party 0 supplies the DB
    # which is secret shared here
    for j in range(ftrs):
        db[i][j] = sint(((i) % 64) + j)
        #db[i][j] = sint.get_input_from(0)

@for_range_opt(c)
def f(i):
    # party 1 supplies the intervals
    # which is secret shared here
    intervals[i][0] = sint(0)
    intervals[i][1] = sint(126)
    #intervals[i][0] = sint.get_input_from(1)
    #intervals[i][1] = sint.get_input_from(1)

#in_interval = Array(c, sint)
agg = sint(0)
#in_interval = sintbit(1)
in_interval_l = Matrix(R, c, sintbit)
in_interval_r = Matrix(R, c, sintbit)
in_interval_f = Array(R, sintbit)
@for_range_opt(R)
def fff(i):
    in_interval_f[i] = sintbit(1)

@for_range_opt_multithread(8, R)
def g(i):
    global agg
    global in_interval_l
    global in_interval_r
    global in_interval_f
    @for_range_opt(c)
    def h(j):
        global in_interval_l
        global in_interval_r
        global in_interval_f
        in_interval_l[i][j] = (intervals[j][0] < db[i][j])
        in_interval_r[i][j] = (intervals[j][1] > db[i][j])
        in_interval_f[i] = in_interval_f[i] & in_interval_l[i][j]
        in_interval_f[i] = in_interval_f[i] & in_interval_r[i][j]

@for_range_opt(R)
def g(i):
    global agg
    global in_interval_f
    agg = agg + ((in_interval_f[i]).if_else(db[i][ftrs - 1], sint(0)))

agg = agg.reveal()
print_ln('Answer is: %s', agg)
    
